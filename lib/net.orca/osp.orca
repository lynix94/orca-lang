using socket;
using thread;
using time;
using pack;
using fun;

using distribute.fs;
using net.httpd;

def result;


mod_name = argv[0].replace('/', '_');
mod_name = mod_name.replace('.', '_');


if fs.isexists(mod_name) {
	mod_time = os.last_write_time(mod_name);
	src_time = os.last_write_time(argv[0]);

	if mod_time >= src_time {
		if httpd.MEMBERS.has_key(mod_name) {
			return httpd.MEMBERS[mod_name](argv[1]);
		}
	}
	else {
		orca.unload(mod_name, httpd);
	}
}

str = fs.read(argv[0]);

.result = """
using osp;
using httpd;

def header;
my.header = '';
header = my.header;
body = '';

def param;
my.param = argv[0];
if my.param == nil {
	my.param = type.map();
}

param = my.param;

def get_session(flag)
{
	session = nil;
	if ..param.has_key('orca_session') {
		session = httpd.session.get_session(..param['orca_session']);
	}

	if session == nil && flag == true { 
		sid = httpd.session.alloc_session();
		..header.push_back('Set-Cookie: orca_session=${sid}');
		session = httpd.session.get_session(sid);
	}

	return session;
}

def free_session()
{
	if ..param.has_key('orca_session') {
		httpd.session.free_session(..param['orca_session']);
	}
}

""";

def enable_session
{
	..result += 
	"""
	session = my.get_session(true);
	""";
}
	

start = 0;
idx = 0;
do {
	idx = str.find('<%', start);
	if idx < 0 {
		.append_str(str[start:]);
		break;
	}
	
	.append_str(str[start:idx]);

	start = idx+2;
	idx = str.find('%>', start);
	if idx < 0 {
		throw osp.parsing <- 'invalid format';
	}

	.append_code(str[start:idx]);
	start = idx+2;
} while true;

.result += 'return [header, body];\n';

fs.remove(mod_name);
fs.write(mod_name, .result);

orca.load(mod_name, httpd);
return httpd.MEMBERS[mod_name](argv[1]);


def append_str(str)
{
	..result += "body.push_back('''${str}''');\n";
}

def append_code(str)
{
	if str[0] == '=' {
		..result += 'body.push_back(' + str[1:] + ');\n';
	}
	elif str[0] == '@' {
		str = str[1:].strip();

		if str == 'session' {
			..enable_session();
		}
	}
	else {
		..result += str + '\n';
	}
}

