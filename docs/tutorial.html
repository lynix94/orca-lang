<html>
<head>
<link type="text/css" rel="StyleSheet" media="all" href="main.css"/>
</head>
<body>

<h1> Orca Programming Language Tutorial</h1>
<h2> version 0.5</h2>
written by Lee, Ki-Yeul (kiyeul.lee@gmail.com)<br>
visit http://orca-lang.or.kr for more information.




<h1> Table of Contents </h1>
<ol start='0'>
<li><a href="#whats_this">What's this</a>
<li><a href="#start">start</a>
<li><a href="#types">Data types</a>
	<ol type='a'>
	<li><a href="#local">local variable</a>
	<li><a href="#integer">integer</a>
	<li><a href="#float">real number</a>
	<li><a href="#string">string</a>
	<li><a href="#regex">regular expression</a>
	<li><a href="#list">list</a>
	<li><a href="#tuple">tuple</a>
	<li><a href="#map">map</a>
	<li><a href="#sbf">set builder form list</a>
	<li><a href="#iterator">iterator</a>
	</ol>
<li><a href="#control">control statement</a>
	<ol type='a'>
	<li><a href="#if">if</a>
	<li><a href="#while">while</a>
	<li><a href="#do_while">do while</a>
	<li><a href="#for">for</a>
	<li><a href="#scope">scope object</a>
	<li><a href="#parallel_do">parallel do</a>
	<li><a href="#parallel_for">parallel for</a>
	<li><a href="#decode">decode statement</a>
		<ol type='i'>
		<li><a href="#string_match">string match</a>
		<li><a href="#regex_match">regular expression match</a>
		<li><a href="#list_match">list match</a>
		<li><a href="#decode_function">decode function</a>
		</ol>
	</ol>
<li><a href="#function_object">function and object</a>
	<ol type='a'>
	<li><a href="#function">function</a>
	<li><a href="#object">object</a>
		<ol type='i'>
		<li><a href="#object_define">object define</a>
		<li><a href="#object_my_owner">simple notaion of my, owner</a>
		<li><a href="#object_special">special character member</a>
		<li><a href="#object_init">one time initializer</a>
		<li><a href="#object_string">name'string' object</a>
		</ol>
	<li><a href="#inherit">inherit</a>
	<li><a href="#using">using</a>
	<li><a href="#virtual_member">virtual member</a>
		<ol type='i'>
		<li><a href="#virt_type">type</a>
		<li><a href="#virt_typename">typename</a>
		<li><a href="#virt_static">static_members</a>
		<li><a href="#virt_members">members</a>
		<li><a href="#virt_parents">parents</a>
		<li><a href="#virt_id">id</a>
		</ol>
	<li><a href="#exception">excpetion</a>
	<li><a href="#lambda">lambda</a>
	<li><a href="#operator">operator overloading</a>
	</ol>
<li><a href="#special">special object</a>
	<ol type='a'>
	<li><a href="#native">Native object</a>
	<li><a href="#parse">parse object</a>
	<li><a href="#uds">UDS object</a>
	<li><a href="#onetime">one time evaluation expression</a>
	<li><a href="#pure">pure object</a>
	</ol>
</ol>


<h1>
	<a name="whats_this">What's this</a>
</h1>

<p>This document is "simple" manual for orca programming language.
You can get more information about orca by run and reading test vectors in orca project.
(run it by ./orca tests/test.orca)

<p>If you have any question, mail me (kiyeul.lee at gmail)
or leave comment on sourceforge or Korean community board.

<h1>
	<a name="start">start</a>
</h1>

Let's start traditional example.
If you type like below,

<div class="shell"><pre>
shell> ./orca
</pre></div>

<p>Interpreter will be come out in console.
Of course it is possible type like "./orca test.orca" or "./orca test" to compile & run source file directly.
And type like below in the prompt of interpreter.

<div class="shell"><pre>
$ print('hello, world');
hello, world
</pre></div>

<p>It print 'hello, world' constant string.
Funny thing is.. above statements could be written like this.

<p>print: 'hello, world';

<p>Because 

function_name ( paremeter_list ) is same as 
function_name : parameter_list

<p>in orca.

<p>This expression is named 'simple call statement' it's purpose is not only typing but also improving readability in lambda programming.
ex, if there is "for_each (items, lambda_function)" function which apply lambda_function to all items of first parameter.
Normal notation is like below,

<p>for_each(list_a, %c{ print(argv[0]);} );

<p>This expression could not be read easily,
But is we use simple call statement, it could be written like below


<div class="code"><pre>
for_each: list_a, %c{
  print(argv[0]);
};
</pre></div>


If lambda function is bigger, it should be more useful.

<h1>
	<a name="types">Data types</a>
</h1>

<h2>
	<a name="local">local variable</a>
</h2>

Variables in function are managed as local variables.
(It's located in Local stack of VM and reenterentable)

<div class="shell"><pre>
$ a = 10;
$ print: a;
10
$ a = 'hello';
$ print: a;
hello
</pre></div>

<p> First line in above code, set a as 10 and prints it.
Then reset a as 'hello' and prints it again.

<p>orca is dynamic type language. So type of variable is changable.

<h2>
	<a name="integer">integer</a>
</h2>


Orca supports integer data types and it's basic operation.
And It supports big number so upper limit is not exist.

<div class="shell"><pre>
$ print: 10000000000000000000000 * 33333333333333333333333333333;
333333333333333333333333333330000000000000000000000 
</pre></div>

<p>Integer has it's internal member functions string() and float().
string() converts integer to string and float() convers integer to real number. string() can has format string as parameter.

<div class="shell"><pre>
$ print: 1.string();
1
$ print: 10.string('%010d');
0000000010
$ print: 30.float();
30
$
</pre></div>


<p>And you can write hexadecimal or Binary Integer by special prefix.
0x on hexadecimal and 0b


<div class="shell"><pre>
$ print: 0xaabbcc;
11189196
$ print: 0xaabbccddeeff00112233445566778899;
226943873990930480490908391077492263065                                                                                            
$ print: 0b11110000;                                                                                                               
240                                                                                                                                
$ print: 0b11110000111100001111000011110000111100001111000011110000;
67818912035696880                                                                                                                 
</pre></div>


<h2>
	<a name="float">real number</a>
</h2>


It supports real number. precision is same as "double" in C/C++.

<div class="shell"><pre>
$ print: 1.0 / 3.0;
0.333333
</pre></div>

<p>Real number has it's internal member functions string() and integer() which convert real number as string or integer.

<div class="shell"><pre>
$ print: 0.3.string();
0.3
$ print: 0.3.string('%3.3f');
0.300
$ print: 0.3.string('%10e');
3.000000e-01
$ print: 1.2.integer();
1
</pre></div>



<h2>
	<a name="string">string</a>
</h2>


<p>String separator could be both of ' and ", and it supports escape character.
And it supports, """ and ''' like python. both of them has same meaning but ''' recognize format string but """ translate all as text itself.

<p>String contains expression in it (like ruby)
It's form is ${ expression }
Below is one example.

<div class="shell"><pre>
$ name = 'james';
$ print: 'hello, ${name}';
hello, james
</pre></div>

<p>String has [] operator. 

<div class="shell"><pre>
$ 'hello, world'[0];
h
$ 'hello, world'[-1];
d
</pre></div>

<p>Minus index means access string backward.

<div class="shell"><pre>
$ 'hello, world'[0:5];
hello
</pre></div>

<p>Above one is exple of silicing operator,
It makes new string which copied from 'from:to' range of original one.

<div class="shell"><pre>
$ 'hello, world'[2:0];
le
</pre></div>

<p>If from is bigger than to, it reverse automatically.

<div class="shell"><pre>
$ 'hello, world'[0:5);
hello,
</pre></div>

<p>If right part is ')' (not ']'), it takes last 'to' index item.
So if you reverse all string, you can try like this.

<div class="shell"><pre>
$ 'hello, world' [-1:0);
dlrow, olleh
</pre></div>


String supports  operator + and *

<p>+ means string concat

<div class="shell"><pre>
$ print: 'hello, ', + 'world';
hello, world

$ print: '3 + 4 = ' + 7
3 + 4 = 7
</pre></div>

<p>* means repeat string n times.
<div class="shell"><pre>
$ print: ‘5 times’ * 5;
5 times5 times5 times5 times5 times 
</pre></div>


Currently, String provides length, find, find_all, strip, lstrip, rstrip, integer, replace interfaces.
And, at 0.4 release it supports hash, starts_with, ends_with, chomp, push_back interfaces.
Below simple examples may be enough for understanding.
length() returns length of string.

<div class="shell"><pre>
$ print: ‘hello, world’.length();
12
</pre></div>

<p>find() returns index which parameter string is found.
<div class="shell"><pre>
$ print: 'hello, world'.find('world');
7
</pre></div>

<p>find_all() find all positions and make result list of them.
<div class="shell"><pre>
$ print: 'hello, world'.find_all('o');
[ 4,8 ]
</pre></div>

<p>First parameter of find and find_all interface could be regular expression which will be described next chapter.
And second, third parameters are acceptable which mean start, end index.
string(), lstrip() and rstrip() interface work like below.

<div class="shell"><pre>
$ print: '"', '    hello,    '.rstrip() + '  world   '.strip() + ' ! '.lstrip(), '"';
"    hello,world! "

$ print: ‘123’.integer() + 100;
223
</pre></div>

integer() make string to integer.

<div class="shell"><pre>
$ print: '30.8'.float();
30.8
$ print: '30e14'.float();
3e+15
$           
</pre></div>

<p>float() make string to real number.

<div class="shell"><pre>
$ print: ‘hello, world’.replace(‘world’, ‘earth’);
Hello, earth
</pre></div>

<p>first argument of replace could be regular expression.
second and thrist arguments are range of replacement (string start, end index)


hash(mod) make simple hash value (integer type). It's max value is INT_MAX but if there is mod value as parameter modulo result is return.

<div class="shell"><pre>
$ a = 'hello, world!';
$ print: a.hash();
1193
$ print: a.hash(100);
93
</pre></div>


chomp(by) divides string by parameter and makes list which have devieded results.
'by' could be string or regular expression.
 
<div class="shell"><pre>
$ a = 'aaaa-bbbb-cccc-dddd';
$ print: a.chomp('-');
[ 'aaaa','bbbb','cccc','dddd' ]
$ 
$ a = 'aaaa-bbbb_cccc:dddd';
$ print: a.chomp(r'[^a-zA-Z]');
[ 'aaaa','bbbb','cccc','dddd' ]
$ 
$ a = 'aaaa-bbbb_cccc-dddd';
$ print: a.chomp(r'[-_]');
[ 'aaaa','bbbb','cccc','dddd' ]
$ 
</pre></div>

<p>string also provides starts_with, ends_with interface.
It's naming is orignated from Java. but parameter could be regular expression.

<div class="shell"><pre>
$ 
$ a = '1111aaaa0000bbbb';
$ print: a.starts_with('1111');
true
$ print: a.starts_with('bbbb');
false
$ print: a.ends_with('bbbb');
true
$ print: a.ends_with('1111');
false
$ print: a.starts_with(r'[0-9]+');
true
$ print: a.ends_with(r'[a-z]+');
true
$ print: a.ends_with(r'[0b]+');
true
$ 
</pre></div>


<p>lower() return string as lowercase
upper() return string as uppercase.

<div class="shell"><pre>
$ 'Hello, World!'.upper();
HELLO, WORLD!
$ 'Hello, World!'.lower();
hello, world!
</pre></div>

<p>char(idx) interface return charactor of string at index of idx.
But char(idx) return character code as number at index of idx

<div class="shell"><pre>
$ 'abc123'.char(0);
97
$ 'abc123'.char(1);
98
$ 'abc123'.char(2);
99
$ 'abc123'.char(3);
49
$ 'abc123'.char(4);
50
</pre></div>

<p>String constants can be rewritten with hexadecimal or binary string format.
by just add h or b before string constatant.

<div class="shell"><pre>
$ print: h'3031323334';
01234
$ print: b'01110011';
s
$ print: b'01110011 01110100';
st
</pre></div>



string supports python style format string.
It's made by overiding the % operator.

<div class="shell"><pre>
$ 'i: %d, f: %f, e: %e, s: %s' % (100, 12.34, 12.34, 'hello, world!');
i: 100, f: 12.340000, e: 1.234000e+01, s: hello, world!
</pre></div>
   







<h2>
	<a name="regex">regular expression</a>
</h2>


To define regular expression, just attach r before constant string.
r'[0-9]+' means regular expression for numbers.

<p>Regular expression that orca provides is made by boost::regex library.
So you can get detail specification from boost regex docs.
In this documents, just simple usages are mantioned.
There are match, find and replace operations are exists in regular expression.


<p>First, match operation could be done like this.



<div class="code"><pre>
str = '123abc456def';
if str == r'[0-9a-z]+':
    print: 'matched';
</pre></div>

<p>Above example will print 'matched'. 
Match operation could be done by ==, != operator.


In above str, if find interface is called like this.

<div class="shell"><pre>
$ print: str.find(r'[a-z]+[0-9+');
( 'abc456',3,9 )
</pre></div>

<p>Matched string('abc456'), start index, end index is come out.



<div class="shell"><pre>
$ print: str.find_all(r'[0-9]+[a-z]+');
[ ( '123abc', 0, 6), ( '456def', 6, 12) ]
</pre></div>

<p>Find_all finds all matched results and start, end index.
And it makes list from founed results.

<div class="shell"><pre>
$ print: str.find_all(r'([0-9]+)[a-z]+');
[ ( ( '123abc',0,6 ),( '123',0,3 ) ),( ( '456def',6,12 ),( '456',6,9 ) ) ]
</pre></div>


<p>Subgroup is supported. if some part of regular expression is parened, that parts are found and added in tuples.
You can detail spec. of subgroup in boost::regex docs.


<p>Finally, replace operation is done like this.

<div class="shell"><pre>
$ print: str.replace(r'[0-9]+', '{{$0}}');
{{123}}abc{{456}}def
</pre></div>

<p>orca regular expression is done by same interfaces which are used in string object (==, !=, find, find_all, replace).
And retunrs list & tuples directly (don't use additional match objects)
It's simple & useful :)


<h2>
	<a name="list">list</a>
</h2>


List is sequence of items which are added or removed later.

<div class="shell"><pre>
$ a = [1,2,3,4,5];
$ print: a, ' ', a[0], ' ', a[-1];
[1,2,3,4,5] 1, 5
</pre></div>

<p>Of cource, assignment and nested lists are possible.

<div class="shell"><pre>
$ a[1] = ['abc', 3];
$ print: a;
[1, ['abc', 3], 3, 4, 5]
$ print: a[1][0];
abc
</pre></div>

<p>Slicing is supported. slicing method is same as method of string.

<p>list have internal member functions push_front, pop_front, push_back and pop_back<br>
push_front insert item to front of list<br>
pop_front remove item of list head<br>
push_back insert item to back of list<br>
pop_back remove item from back<br>
These four functions return modified list itself<br>

<div class="shell"><pre>
$ a= [1,2,3];
$ print: a.push_back(4);
[ 1,2,3,4 ]
$ print: a.pop_back();
[ 1,2,3 ]
$ print: a.push_front('100');
[ '100',1,2,3 ]
$ print: a.pop_front();
[ 1,2,3 ]
</pre></div>

<p>tuple() make new tuple which have same item of list.
<div class="shell"><pre>
$ a = [1..10];
$ print: a, a.tuple();
[ 1,2,3,4,5,6,7,8,9,10 ]( 1,2,3,4,5,6,7,8,9,10 )
</pre></div>

<p>size() return list length
empty() returns true if list is empty.
clear() clear list.

<div class="shell"><pre>
$ a = [1..10];
[ 1,2,3,4,5,6,7,8,9,10 ]
$ print: a.size();
10
nil
$ a.empty();
false
$ a.clear();
[  ]
$ a.empty();
true
$ 
</pre></div>



begin(), end() return iterator of list which point begin (or end) of list.

<div class="shell"><pre>
$ list = [1,2,3];
$ i = list.begin();
$ e = list.end();
$ print: i();
1
$ i.next();
$ i();
$ i(3);
$ print: list;
[ 1,3,3 ]
$ print: i == e;
false
$ i.next();
$ e.prev();
$ print: i == e;
true
</pre></div>



<p>find(value) function find position which have value and return it's iterator.

<div class="shell"><pre>
$ list = [1,2,3];
$ i = list.find(2);
$ print: i();
2
$ i.prev();
$ print: i();
1
</pre></div>


list iterator have insert(), remove() interface.
insert() insert new item in front of itself.
remove() remove item which itself had pointed.

<div class="shell"><pre>
$ list = [1,2,3];
$ i = list.find(2);
$ i.insert(100);
$ print: list;
[ 1,100,2,3 ]
$ i = list.find(100);
$ i.erase();
$ print: list;
[ 1,2,3 ]
</pre></div>

<p>list and iterator have timestamp in it. so if there is change in container (list, tuple and map). it's old iterators are invalidated. so if these iterators are used, exception occurs.


list has sort interface which sort it's internal items.
If you call this interface without parameter, Default comparison is worked and items are sorted in increase order.
If you pass compare function when you call sort, Sort use it as '<' operator.

<div class="shell"><pre>
$ a = [1,3,2,4,2];
[ 1,3,2,4,2 ]
$ a.sort();
[ 1,2,2,3,4 ]
$ print: a;
[ 1,2,2,3,4 ]
$ 
$ a.sort(%c{ return argv[0] >= argv[1]; });
[ 4,3,2,2,1 ]
</pre></div>

In above example, User pass >= lambda function as parameter so sorting has done with descending order.


<h2>
	<a name="tuple">tuple</a>
</h2>


Tuple is almost same as list. but it has more efficient in random access. (It is made by vector in C++/STL)
But interface of tuple is same as list.


<div class="shell"><pre>
$ a = ( 1, 3, 4 );
$ print: a,' ',a[1];
( 1, 3, 4 ) 3
</pre></div>

<p>tuple has it's internal function push_back and pop_back.
push_back insert new item to back of tuple.
pop_front remove item from back

<div class="shell"><pre>
$ a = (1,2,3);
$ print: a.push_back(100);
( 1,2,3,100 )
$ print: a.pop_back();
( 1,2,3 )
</pre></div>

<p>list() make new list which have same items of tuple.
length() return length of tuple
empty() return true if tuple is empty.
clear() initilize tuple.

<div class="shell"><pre>
$ a = (1..10);
$ print: a, a.list();
( 1,2,3,4,5,6,7,8,9,10 )[ 1,2,3,4,5,6,7,8,9,10 ]
$ print: a.size();
10
$ a = (1..10);
( 1,2,3,4,5,6,7,8,9,10 )
$ a.empty();
false
$ a.clear();
(  )
$ a.empty();
true
</pre></div>


<p>tuple provides begin(), end(), find() interfaces which work like those of list.
but does'nt provides insert() and remove()

<div class="shell"><pre>
$ tp = (1,2,3);
$ i = tp.begin();
$ e = tp.end();
$ print: i();
1
$ i.next();
$ print: i();
2
$ print: i(3);
3
$ print: tp;
( 1,3,3 )
$ print: i == e;
false
$ i.next();
$ e.prev();
$ print: i == e;
true
$
$ tp = (1,2,3);
$ i = tp.find(2);
$ print: i();
2
$ i.prev();
$ print: i();
1
</pre></div>


<h2>
	<a name="map">map</a>
</h2>


<p>Map is key-value container like dictionary in ruby and python.
or map in STL.

<div class="shell"><pre>
$ a = { ‘harry’:100, ‘tom’:20 };
$ print: a[‘harry’];
100
</pre></div>

<p>Map provides keys, values interfaces which returns list of keys or values.
But maybe it will be changed as virtual object which points keys (or values) in map (like python 3.0)


length() return length of map which means count of items.
empty() return true if map is empty.
clear() initilize map.

<div class="shell"><pre>
$ a = { 1:2, 3:4 };
$ print: a.size();
2
$ a.empty();
false
$ a.clear();
{  }
$ a.empty();
true
$ 
</pre></div>



has_key(val) return true if there are key value of 'val'.
erase_key(val) erase item whose key is 'val'

<div class="shell"><pre>
$ a = {1:2, 3:4 };
$ print: a;
{ 1:2,3:4 }
$ print: a.has_key(1);
true
$ print: a.has_key(100);
false
$ print: a.erase_key(1);
nil
$ print: a.has_key(1);
false
$ print: a;
{ 3:4 }
$ 
</pre></div>


<p>map provides begin(), end() interfaces. map is sorted associative container. so if traverse from begin() to end(), programmer can access ordered items.
Calling of iterator returns item value. but map is key-value pair so it returns (key, value) tuple. If you want access key or value directly, call it.first() or it.second()

<div class="shell"><pre>
$ m = { 1:100, 2:200, 3:300 };
$ a = m.begin();
$ print: a(), a.first(), a.second();
( 1,100 )1100
$ a.next();
$ print: a(), a.first(), a.second();
( 2,200 )2200
$ a.next();
$ print: a(), a.first(), a.second();
( 3,300 )3300
$ a.next();
</pre></div>

uncaugted exception: orca.iter out of range
recent call-stack trace


you can change value by iterator by call it with value. but key could'nt be changed by iterator (change of key means ordering is changed) so only value is changed.

<div class="shell"><pre>
$ a = { 1:100, 2:200, 3:300 };
$ it = a.begin();
$ it(1000);
$ it.next();
$ it(2000);
$ it.next();
$ it(3000);
$ print: a;
{ 1:1000,2:2000,3:3000 }
</pre></div>


find() return iterator which points item that has same key value.

<div class="shell"><pre>
$ a = {1:100, 2:200, 3:300};
$ it = a.find(2);
$ print: it();
( 2,200 )
$ 
$ it = a.find(100);
$ print: it == a.end();
true
$ print: it();
uncaugted exception: orca.iter out of range
recent call-stack trace
>> mapiter      (internal 0)
>> orcaRoot     (internal 0)
>> orcaRoot     (internal 0)
>> orcaRoot     (internal 0)
</pre></div>


map also provides lower_bound and upper_bound. They are simillar like find. find return end() if there are no item has same key but lower_bound and upper_bound return position could be inserted. 

<div class="shell"><pre>
$   a = { 1:1, 2:2, 4:4, 5:5, 6:6 };
$   i = a.lower_bound(3);
$   print: i();
( 4,4 )
$   i = a.upper_bound(3);
$   print: i();
( 4,4 )
$  i = a.lower_bound(4);
$  print: i();
( 4,4 )
$   i = a.upper_bound(4);
$   print: i();
( 5,5 )
</pre></div>


keys() return list which have keys of map.
values() return list which have values of map.

<div class="shell"><pre>
$ a = { 1:'value 1', 'two':2, 'key3':[1,2,3] };
$ print: a.keys();
[ 1,'key3','two' ]
$ print: a.values();
[ 'value 1',[ 1,2,3 ],2 ]
</pre></div>


<h2>
	<a name="sbf">set builder form list</a>
</h2>

orca supports set builder form which is build up by lazy evaluation.
Original set builder form which generates even number from between 1 and 10 is like this

<p>[x|x<-n, 1<x<10, x%2 = 0]

<p>But it have to get some changes as programming notation.
First n is not defined orca so source generator could be written as
x<-1~10 directly. and to notify SBF (not normal list) '%' is placed in front of list.

<p>So above SBF is writtend like this in orca.

<div class="shell"><pre>
$ print: %[x|x<- 1~10, x%2 == 0];
[2,4,6,8,10]
</pre></div>

<p>Let's see more detail..

<p>%[x|x<- 1~10, x%2==0] have three part

<p>Firts x before | is functional part.
Which is final expression of generated inputs by right part.
If we change SBF as %[x-1|x<-1~10, x%2 == 0], it prints odd number.
Next x<-1~10 is generation part, it generate number between 1 and 10.
Similarilly, x <- -10~ generates number greater than -10
(it means unbounded number will generates, it's possible because of lazy evaluation)

x<- ~100 generates numbers which is less than 100.
Not only integer range form, 
List item or iterator object or other SBF list could be used.
As an example,

<p>%[x|x<-[1..10], x%2 == 0] makes same result.

x<- (list object) means "all items in object".
In this case it's an list constant but variables are also posible like x <- b.

But this type of definition make list at one in run time, so it have initial overhead.
As an example, if you define like this range form.

<div class="shell"><pre>
$ a = %[x|x<-1~100000000];
$ print: a[10];
11
</pre></div>

<p>It returns quickly but,

<div class="shell"><pre>
$ a = %[x|x<-[1..100000000]];
$ print: a[10];
</pre></div>

<p>In this case, it requires just 11th item but list definition in SBF make all list at one time so it resumes much time and memory.
So range form, another SBF and iterator object is more effective in lazy evaluation.
And last part is condition. x%2 == 0 which check to all items.
This part should be boolean expression and could be multiple.

<div class="shell"><pre>
$ print: %[x|x<-1~10, x%2 == 0, x%3 == 0]
</pre></div>

<p>prints out [6]. first condition x%2 selects 2,4,6,8,10 and second condition x%3 select only 6.
Generation part also could be multimple.  See the below code.

<div class="shell"><pre>
$ print: %[(x,y)|x<-1~5, y<-3~5];
[ ( 1,3 ),( 1,4 ),( 1,5 ),( 2,3 ),( 2,4 ),( 2,5 ),( 3,3 ),( 3,4 ),( 3,5 ),( 4,3 ),( 4,4 ),( 4,5 ),( 5,3 ),( 5,4 ),( 5,5 ) ]
</pre></div>

<p>When x generates 1~5, y generates 3~5 each. 
You can add condition to this.

<div class="shell"><pre>
$ print: %[(x,y)|x<-1~5, y<-3~5, x==y];
[ ( 3,3 ),( 4,4 ),( 5,5 ) ]
$
</pre></div>


It select what x == y. so final result is like above.

<p>Let's see more useful example that find prime number.
First, define factor which returns exact divisors.



<div class="shell"><pre>
$ def factor(n)
* {
*   return %[x|x<-1~n, n%x==0];
* }
* 

$ print: .factor(100);
[ 1,2,4,5,10,20,25,50,100 ]
</pre></div>

<p>And second, define prime which prints out prime numbers between 1 and n like below,


<div class="code"><pre>
def prime(n)
{
  return %[x|x<-1~n, ..factor(x) == [1, x]];
}
</pre></div>

<p>This function get n and calculate factors between 1 and n.
Then check it has only 2 items (1 and itself)
It is definition of prime number itself.
Let's test it

<div class="shell"><pre>
$ print: .prime(100);
[ 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97 ]
$ 
</pre></div>

<p>It works well :)
And then see another famous functional programming example. Quick sort.


 
<div class="code"><pre>
decode def qsort(a)
{
  [] ->
    {
      return [];
    }
  %x:%xs -> 
    {
      return qsort(%[a|a<-xs, a<=x]) + [x] +  qsort(%[b|b<-xs, b>x]);
    }
}

$ print: .qsort([-7, 1.2, 30, 4]);
[ -7,1.2,4,30 ]
</pre></div> 


Decode function qsort gets list and if list is empty just return.
If list is not empty, cut off first item and assign it to x (this is pivot).Then reorder remaining items so that all the items with values less than pivot come before the pivot. while others come after the pivot.
and recursivley do qsort to moved item groups.

<p>This is same as quick sort definition exactly.

<p>range generator of Set builder form could be other data types (floating number or etc)
Integer is descrete number so It has default increase/decrease step. (number 1)
But, Floating number (and other data types) is not descrete number so, user add increase/decrease step on generator

<p>You can write generator with step like this form. x <- START ~ END : STEP
If START and END are integer type, STEP could be omitted and It's implicit value is 1.

<p>below SBF generator floating number from 0 to 10 by 0.1 step.


<div class="shell"><pre>
$ a = %[x|x<- 0 ~ 10 : 0.1];
[ 0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3,3.1,3.2,3.3,3.4,3.5,3.6,3.7,3.8,3.9,4,4.1,4.2,4.3,4.4,4.5,4.6,4.7,4.8,4.9,5,5.1,5.2,5.3,5.4,5.5,5.6,5.7,5.8,5.9,6,6.1,6.2,6.3,6.4,6.5,6.6,6.7,6.8,6.9,7,7.1,7.2,7.3,7.4,7.5,7.6,7.7,7.8,7.9,8,8.1,8.2,8.3,8.4,8.5,8.6,8.7,8.8,8.9,9,9.1,9.2,9.3,9.4,9.5,9.6,9.7,9.8,9.9,10 ]
</pre></div>

<p>If set builder form list's length is infinite, orca prints it like below,
<div class="shell"><pre>
$ a = %[x|x<-1~];
[ 1,2,3,4,5,6,7,8,9,10, ... ]
</pre></div>

<p>In that case (infinite) size() interface return -1.
<div class="shell"><pre>
$ print: a.size()
-1
</pre></div>




<h2>
	<a name="iterator">iterator</a>
</h2>


<p>Iterators of container have simillar interface with STL.
Rules of current implementation are like belows.

<ul>
<li> If you want to move next item, call next() and it change it's position and return itselft.
<li> If you want to move prev item, call prev() and it change it's position and return itselft.
<li> If result of next and prev is out of range, next, prev return nil.
<li> If you want value of item which iterator points out. call iterator. (like, value = it(); )
<li> If you want change value of item which iterator points out. call iterator with parameters ( like, it(3) )
<li> Iterator have operator_eq, operator_neq so they could be compared. (==, !=)
<li> map iterator have operator_lt so it could be compared ( ==, !=, <, <=, >, >=) 
<li> If you access invalid iterator, orca.iter exception occurs.
</ul>

<p>And here is additional rules of contaner.

<ul>
<li> You can get iterator which points out first posion, call begin()
<li> next(), prev() can get integer parameter. next(2) means next(), next().
<li> You can get iterator which points out last item. call last().
<li> You can get iterator which points out next of last posion, call end() (real last postion is end().before())
<li> You can find item and get it's iterator by call find()
<li> If you want erase item. call erase() interface of iterator (but tuple iterator does'nt support)
<li> If you want insert new item call insert() interface of iterator (but tuple and map does'nt support)
<li> If order of container is changed, old iterators are invalid and exception occus if they are referred.
</ul>




<h1>
	<a name="control">control statement</a>
</h1>


<h2>
	<a name="if">if</a>
</h2>


<p>Structure of if statement is 
<p>if bool_expression : statement_list
<p>And it could be exists that additional elif and else clauses.j



<h2>
	<a name="while">while</a>
</h2>

<p>Structure of while statement is

<p>while boolean_expression : statement_list

<p>This is worked like C/C++ while



<div class="code"><pre>
a = sum = 0;
while a < 10: {
  sum  += a;
  a+=1;
}
</pre></div>

<p>Above example is sum all of 0 to 9.


<h2>
	<a name="do_while">do while</a>
</h2>


<p>Structure of do while statement is

<p>do stement_list while boolean_expression


<div class="code"><pre>
a = sum = 0;
do {
  sum += a;
  a += 1;
} while a < 10;
</pre></div>

<p>Above example makes same result (of while example)


<h2>
	<a name="for">for</a>
</h2>


The structure of for statement is 

<p>for a in b : statement_list

<p>b could be list, tuple and map. 
And iterator object and set builder form list are possible as b.
a will be assigned all items in b in order, and statement_list are excuted.
Let's look at example.

<div class="code"><pre>
sum = 0;
for a in [1..10]:
  sum += a;
</pre></div>

<p>Above example sums up 1 to 10. 
[1..10] generate list [1,2,3,4,5,6,7,8,9,10] and each item is assigned to a in order.
And sum += a is excuted every time.
Iterator object could be used, iterator object is that have next() interface. 
Simple example is below



<div class="code"><pre>
def one_to_hundred
{
  my.cur = 0;
  return my;

  def cur;
  def next() {
    owner.cur += 1;
    if owner.cur > 100:
    throw done;

    return owner.cur;
  }
}

it = my.one_to_hundred();

sum = 0;
for i in it:
  sum += i;
print: sum;
</pre></div>


<h2>
	<a name="scope">scope object</a>
</h2>


<p>If object has scope_start(0, scope_end() interface, it could be used as scope statement.
The structure of scope statement is like below

<div class="code"><pre>
object {
  statement_list
}
</pre></div>

<p>In this case, before statement_list is excuted, object.scope_start() is called automatically.
And after the excution of statement_list is done object.scope_end() is called.
And if there is exception throwing or return in statement_list, object.scope_end() is called automatically.

<p>As an example, If you make a mutex lock on some code area.


<div class="code"><pre>
usign ipc;

def scope_mutex
{
    def mtx;

    def new {
        clone owner;
        ..mtx = new ipc.mutex;
    }

    def scope_start {
        ..mtx.lock();
    }

    def scope_end {
        ..mtx.unlock();
    }
}


def fun {
    mtx = ..scope_mutex.new();

    mtx {
        foo();
        bar();
    }
}
</pre></div>

<p>If you run fun(),

<pre>
mtx.scope_start();
foo();
bar();
mtx.scope_end();
</pre>

<p>Will be excuted in order. if there is exception throwing from foo(). bar() is not excuted but mtx.scope_end() is called automatically.
And in below case, mtx.scope_end() is called also.


<div class="code"><pre>
mtx {
  foo();
  return;
}
</pre></div>

<p>This statement could be used to all pairing cases.
likes making CS, resource open/close, timer start/end.. etc


 

<h2>
	<a name="parallel_do">parallel do</a>
</h2>


orca provides thread module for parallel processing already.
But parallel programming by using thread API requires special caution in design level.
If you change sequential program to parallel programm, maybe main logic flow should be changed.

<p>So orca provides parallel statements for supporting easy parallel programming.


<div class="code"><pre>
b = foo(a);
user_log ('result of foo: ${b}');
bar(b);
</pre></div>

<p>Think about above code, main logic excutes foo and assign it's result to b.
Then it call bar using b (which is result of foo())
In this case, bar(b) is depend on foo(a). so it must be sequential.<br>
But, bar(b) is not depend on result of user_log('result of foo: ${b}');
So user_log could be parallel excuted.
So in orca 


<div class="code"><pre>
b = foo(a);
parallel do {
  user_log('result of foo: ${b}');
}
bar(b);
</pre></div>

<p>If you change code like above,
Main thread runs just

<pre>
b=foo(a);
bar(b);
</pre>

<p>And when foo(a) is done, additional sub thread is created and run statements in parallel do block. 
This is very useful and easy because sub thread in parallel do statements can access local variables of main thread.
So if you want make some block to be parallized, just let them into parallel do statements.
Then main thread will skip that parts.<br>

Here is another example



<div class="code"><pre>
using time;
using stopwatch;

sw = stopwatch;

sw.start();
time.msleep(1000);

sw.lap('without parallel do: ');

sw.start();
parallel do {
  time.msleep(1000);
}

sw.lap('with parallel do: ');
</pre></div>

<p>without parallel do: 999 ms, 599 us
with parallel do: 399 us


Like above, with parallel do, main thread is not blocked by time.msleep(1000)
So it can run down to sw.lap() more fast.

<p>I recommend parallel do statements to IO bound job.
Especially logging, async communication and etc.
But in case of CPU bound job, maybe parallel for statement (which is in next chapter) is more useful. 


<h2>
	<a name="parallel_for">parallel for</a>
</h2>



<div class="code"><pre>
parallel for a in input_list
{
  statement_list;
}
</pre></div>

<p>The grammer of parallel for statement is like above,
And simillar to for statement,
all itemes in input_list (list, set builder form, iterator object are could be as input_list) is assigned to a then statement_list is excuted.
But excution is not sequential but parallel.
Let's see simple example
 

<div class="code"><pre>
parallel for a in [1,2,3,4,5]:
{
  foo(a);
}
</pre></div>

Above code call foo(1), foo(2), foo(3), foo(4) and foo(5)  in same time logically.
But for optimization, max thread num in same time is number of CPU core.
In dual core system, 2 threads are made and excute all input list in same time.
And in quad core system, 4 threads are made and do them all.
Like parallel do statment, this sub threads can access local variables in main thread.

So if you want parallelize for statement. just add "parallel" in front of that.
(but logic in satement_list should be independent)
Unlike parallel do statement, main logic wait until all sub thread is done.
And be ware that there is assigning overhead,
So it is not recommended to use parallel for statement to very simple work.

<p>Here is another example



<div class="code"><pre>
using time;
using stopwatch;

sw = stopwatch;

sw.start();
for a in [1..10]: {
  print: a;

  c = 0;
  for b in %[x|x<-1~100000]: {
    c = c+1;
  }
}

sw.lap('with for: ');

sw.start();
parallel for a in [1..10]: {
  print: a;

  c = 0;
  for b in %[x|x<-1~100000]: {
    c = c+1;
  }
}

sw.lap('with parallel for: ');

C:\Lab\orca>orca test_for
1
2
3
4
5
6
7
8
9
10
with for: 421 ms, 875 us
1
2
3
4
5
6
7
8
9
10
with parallel for: 93 ms, 750 us
</pre></div>


<p>Above code is run under quad core system, 
It shows that total run time is shorten to 1/4.

<p>You can add additional by, per option to parallel statement. for example,


<div class="code"><pre>
parallel for a in [1..100] by 3 per 30: 
  print: a; 
</pre></div>

<p>above code means that run 3 threads with 30 items in one time.
So, working ranges are set as [1..30],[31..60],[61..90],[91..100] and 3 threads are invoked with these working ranges.

<p>by and per option are could be omitted. in this case, default value of by is cpu num in current machine and devault value of per is 1.
But, If there is one CPU in machine, default value of by is 2 (because It's possible user use blocking IPC on his/her code)

<p>Normal expression is possible as value of by, per.
You can use system module for balancing threads.


<div class="code"><pre>
a = [1..1000]; 
parallel for i in a by (cpu = system.cpu_n() * 2) per (a.size() / cpu): { 
  print: i; 
} 
</pre></div>

Above code select adaptive thread number in run time.






<h2>
	<a name="decode">decode statement</a>
</h2>


This statement is simillar to pattern matching in Earlang.
But there is some more advanced feature in it.

<p>Basically, it's grammar is like below



<div class="code"><pre>
decode (A)
{
  pattern_list -> statement_list
  pattern_list -> statement_list
  pattern_list -> statement_list
  ...
}
</pre></div>

<p>A is compared to pattern_lists in order.
If A is matched to one of left side pattern_lists then right side statement_list is excuted.


List, vector, list type object (SBF, iterator) and string could be placed in A,
And pattern_list could be composed by string, regular expression and list.

<p>Let's examine it in each case
 
<h3>
	<a name="string_match">string match</a>
</h3>


<div class="code"><pre>
decode('orca')
{
  'orca' -> print: 'orca, matched';
  'python' -> print: 'python, matched';
}
</pre></div>

<p>This code print 'orca, matched'.
It seems like to see simple switch statement.

<p>And here is more complex example.


<div class="code"><pre>
decode(str)
{
  'send:', %to, ':', %msg -> ..send(to, msg);
  'connect:', %to -> ..connect(to);
  %fail -> ..error(fail);
}
</pre></div>

<p>Think about simple chatting server protocol, 
First pattern list is for send message format.

<p>If client send to server 'send:tom:hello, tom', then it matched to first pattern list,
Then 'tom' is assgined to to and 'hello, tom' is assigned to msg. 
And finally, ..send(to, msg) is run.
If client send to server 'connect:tom', it matched to second pattern list.
Then ..connect('tom') is called.<br>

Last pattern is for 'default' it matched to all input case so it must be last pattern.(because matching is done by order of pattern list)<br>

If there is unknown input string, it matched to %fail and it's value assgined to fail variable then ..error(fail) is called.


<h3>
	<a name="regex_match">regular expression match</a>
</h3>

<p>Regex could make more conveniant and flexible pattern matching.


<div class="code"><pre>
decode (str)
{
 'id:', r'[a-zA-Z][a-zA-Z_0-9]*', ', number:', r'[0-9]+' -> print: 'matched!!';
  %fail -> print: 'failed..';
}
</pre></div>

<p>Above code print 'matched!!' in case of 'id:lynix, number:103'.
It print 'failed..' in case of 'id:3aa, number:10' or 'id:lynix, number:10a'.
If you want to know real value which is matched to regex.
Change above to like this,


<div class="code"><pre>
decode (str)
{
 'id:', %id=r'[a-zA-Z][a-zA-Z_0-9]*', ', number:', %number=r'[0-9]+' -> print: 'matched!!, id=${id}, number=${number}';
  %fail -> print: 'failed..';
}
</pre></div>

<p>Then if str is 'id:lynix, number:103' then "matched!!', id=lynix, number=103" is come out.


<h3>
	<a name="list_match">list match</a>
</h3>

<p>List matching is also possible,


<div class="code"><pre>
decode ([1,2,3,4,5])
{
 [1, 2], %mid, [4, 5] -> print: mid;
}
</pre></div>

<p>Above code prints [3].
Traditional list matching process is head:tail matching.
So orca supports this also.



<div class="code"><pre>
decode ([1,2,3,4,5])
{
  [] -> print: 'empty';
  %head:%tail -> print: 'head: ${head}, tail: ${tail}';
}
</pre></div>

<p>This code prints 
head: 1, tail: [2,3,4,5]


<h3>
	<a name="decode_function">decode function</a>
</h3>

<p>Like the many examples of LISP, list pattern matching is done recursively.
Let's see below example.


<div class="code"><pre>
def print_list(a)
{
  decode (a)
    {
	[] -> print: 'done';
    %head:%tail -> {
		print: head;
		print_list(tail);
	}
    }
}

.print_list([1,2,3,4,5]);
</pre></div>

<p>This code print out.

<pre>
1
2
3
4
5
done
</pre>

<p>But this code is so complex, 
So you can use decode def for conveniance.
Below code is same as above example.


<div class="code"><pre>
decode def print_list(a)
{
  [] -> print: 'done';
  %head:%tail -> {
		print: head;
		print_list(tail);
  }
}
</pre></div>


<p>Like this, orca can process string easily and without side effects like functional programming.


<p>And decode supports user defined function as match value from 0.4 release.
It's simple upgrade but very useful.
If you see module xml and json in lib directory of orca, you can find It's very useful to decoding nested string.<br>

as a simple example If there is string like below,<br>

str = " [1, [2], 3 ] "<br>

<p>If you want read it and convers it to list.
(dont think about eval(), just decode string)

<p>If you parse it by decode statement (old version)
programmer may try it like this,


<div class="code"><pre>
decode def tolist(str)
{
	'[', %body, ']' -> 
		{
			ret = tolist(body);
			if type.is_tuple(ret): 
				return ret.list(); 
			return [ ret ];
		}
	%head, ',', %tail ->
		{
			h = tolist(head);			
			t = tolist(tail);
			if type.ist_tuple(t):
				t = t.list();

			return t.push_front(h);
		}
	%value = r'[0-9]+' ->
		{
			return value.integer();
		}
}
</pre></div>

<p>In this case, programmer want string "1, [2], 3" is assigned to body.
but, "1, [2" is assgined (becase decode match first occourence) so match is failed.<br>
So, If you use user defined match function like below,


<div class="code"><pre>
using match;

decode def tolist(str)
{
	'[', %body = match.bracket, ']' -> 
		{
			ret = tolist(body);
			if type.is_tuple(ret): 
				return ret.list(); 
			return [ ret ];
		}
	%head = match.comma, ',', %tail ->
		{
			h = tolist(head);			
			t = tolist(tail);
			if type.ist_tuple(t):
				t = t.list();

			return t.push_front(h);
		}
	%value = r'[0-9]+' ->
		{
			return value.integer();
		}
}
</pre></div>

<p>decode statement call match.bracket with "1, [2], 3]" as parameter. and match.bracket function matches valid scope of [ and ]. And match.bracket matches string "1, [2], 3" and assign it to body. and match is success.<br>
and action code is called. and tolist(body) is called and second rule is matched so head is "1" and tail is "[2], 3"<br>
and finally, list [1, [2], 3] is return.<br>
like this orca can traits nested string very easily.

재정의된 연산자는 객체가 왼쪽에 있을 때 적용되데, 오른쪽에 있더라도 왼쪽에 있는 객체가 연산자가 재정의되지 않았다면 적용된다.
즉, obj 가 + 연산자가 재정의된 객체라 할때,

obj + 1 은 obj.'+'(1) 이 호출되는데 1 + obj 의 경우도 오르카가 알아서 obj.'+'(1) 을 호출해준다.
단, obj_b 가 '+'연산자를 정의했다면.

obj + obj_b 는 obj.'+'(obj_b) 를 호출하지만, obj_b + obj 은  obj_b.'+'(obj) 를 호출한다. 좌측 우선이되 적용되지 않고 교환법칙이 성립하는
연산자이면 우측 객체의 연산자를 사용한다.

단,  -, / 연산자는 교환법칙이 성립하지 않는다.

obj - 1 은 obj.'-'(1) 이 호출되지만 1 - obj 은 obj.'-rev'(1) 가 호출된다. -rev 객체에서 순서를 바꾼 후 처리하게 구현하면 된다.




<h1>
	<a name="function_object">function and object</a>
</h1>

<h2>
	<a name="function">function</a>
</h2>


Function is just runnable object.

<p>You can define function like below.


<div class="code"><pre>
def name {
  statement_list
}
</pre></div>

<p>As an example, function that sum up two parameter is like below,


<div class="code"><pre>
def add(a, b) {
    return a + b;
}

print: my.add(10, 20);
</pre></div>

<p>This prints 30
If you want variable arguments,

<div class="code"><pre>
def sum_all(…) {
    sum = 0;
    for a in argv:
        sum += a;

    return sum;
}

print: my.sum_all(1,2,3);
6
</pre></div>

<p>You can define it like above. ... means variable arguments.
And those are inserted in argv list. ... must be end of parameter list.
That means that def (a, ..., b) is illegal but def (a, b, ...) is correct.




<h2>
	<a name="object">object</a>
</h2>


<h3>
	<a name="object_define"> define object </a>
</h3>

<p>Previous function definition is just define one object which is runnable.
And now, let's define object which have member variables.


<div class="code"><pre>
def counter {
    def c;

    def inc {
        owner.c += 1;
    }

    def dec {
        owner.c -= 1;
    }

    my.c = 0;
}

foo = my.counter.clone();
foo();
print: foo.c;
foo.inc();
print: foo.c;
foo.dec();
print: foo.c;
</pre></div>

<p>Above example prints out 0, 1, 0.

<p>Let's see more detail again.
First we define counter object by "def counter" and in it's area, we define it's member variable c, member function inc, dec and describe counter's code
(my.c = 0)

<p>In this defines, all of counter, c, inc, dec are independent whole object.
They just have relations to others. and by that they can access each other.

<p>In the position of inc and dec, counter means their "owner". so if they access to counter's member c, have to do that by owner.c += 1 or owner.c -= 1<br>
In the position of counter inc, dec and c is "my" member. so It can access them in his scope by my.* like code which is include in it "my.c = 0"<br>
(think about "self" of python)

<p>This code will be written in python like below,


<div class="code"><pre>
class counter:
  def __init__(self):
    self.c = 0;

  def inc(self):
    self.c += 1;

  def dec(self):
    self.c -= 1;

</pre></div>

<p>But, this simple definition have many pre-defined rule inside.
In position of inc, self means not inc but counter. so, inc and counter is binded strongly. inc is just member function and counter is just member container.<br>
But in all of orca, inc, dec, c and counter is just object.

<p>And inc and counter is loosly binded. so inc could be member function of other object later. (if it's owner is changed)
It's more minimal and atomic to object orient concept in my thought.
Think about another example.

<p>If programmer design thread API which will launched new thread. 
He must choose function or class as it's parameter in design time.
But in orca, both of them are possible like this,


<div class="code"><pre>
def foo {
    print: ‘hello, thread’;
}

thread.run(my.foo);

def foo {
    # some init code here
    …
    my.run();
    return;

    def run {

    }

    def blah {

    }
}

thread.run(my.foo);
</pre></div>

<p>So in same API, foo could be a simple function or class which have it's member.


<h3>
	<a name="object_my_owner"> simple notation of my, owner</a>
</h3>

There is simple notation for owner and my,
Those are .. and . (.. for owner, . for my)
So above one could be written as


<div class="code"><pre>
def counter {
    def c;

    def inc {
        ..c += 1;
    }

    def dec {
        ..c -= 1;
    }

    .c = 0;
}
</pre></div>



<h3>
	<a name="object_special">special character member</a>
</h3>

<p>When you refer member of object.
You type like this form. object.member.
As an example, io.print means refer print member of io object.

<p>In this form, member name don't includes special characters.
If member name has special characters in it, You should access it with string constant form.

<p>Like below form. 
(cf. If you want to access it with variables io.members[var_name] is possible)

<div class="code"><pre>
def foo
{
  def ‘+’(rhs)
    {
      …
    }
}
</pre></div>

As an example, operator module has below members.


<div class="shell"><pre>
$ operator.members;
{ '!=':!=,'%':%,'&&':&&,'*':*,'+':+,'-':-,'/':/,'<':<,'<=':<=,'==':==,'>':>,'>=':>=,'||':||, }
$ operator.'+'(3,4);
7
</pre></div>



<h3>
	<a name="object_init">one time initializer</a>
</h3>

<p>You can define foo object which get parameter and add to it's internal list member like below,

<div class="code"><pre>
def foo(a)
{
	def item;

	if my.item == nil: 
		my.item = [];

	my.item.push_back(a);
}
</pre></div>

<p>In above code, you should check my.item's type in run time.
But you can use one time initializer to initialize my.item in module loading time.

<p>one time initializer is written like this,

<p>def name := expression 

<p>expression's result value is assigned to name member when module is loaded.
This assigment do only one time and It's not do on runtime.

<p>So, above example can be rewitten like below,

<div class="code"><pre>
def foo(a)
{
	def item := [];
	my.item.push_back(a);
}
</pre></div>



<h3>
	<a name="object_string">name'string' object</a>
</h3>


<p>With an date example,
If you want to get days between 2011-04-03 and 2010-01-01.


<div class="shell"><pre>
$ using date;
$ print: date.clone('2011-04-03') - date.clone('2010-01-01');
457
</pre></div>

<p>You can type like above.
But in many cases, object_name.clone('string') expression is bothering to type and decrease readability. 
So, There is another way to express it.

object_name'string' has equal meaning to object_name.clone('string')

So above example could be rewritten like this,

$ date'2011-04-03' - date'2010-01-01';
457




<h2>
	<a name="inherit">inherit</a>
</h2>


Inheritance definition is like below,

<p>def derived : base { ... }

<p>Like this, you can list up derived's parants on right side of colon.


If you want to make new object, use clone internal interface.

<p>a = b.clone(10);

<p>This make new b object and assign it to a;
And if b has init member in it, after make new b object, b.init(10) is called automatically.



<h2>
	<a name="using">using</a>
</h2>


using keyword loads module.

<p>If there is sample.orca file in current folder or folders in ORCA_PATH environment varialble.
If programmer want to use that file.
Type like this, 

<div class="shell"><pre>
$ using sample;
</pre></div>

<p>Then orca find 'sample.orca' (or 'sample') and compile it and insert that into 'root'
If user want to call object foo which is defined in sample.orca

<div class="shell"><pre>
$ root.sample.foo();
</pre></div>

<p>Or already sample is in namespace

<div class="shell"><pre>
$ sample.foo();
</pre></div>

<p>Is possible too. If you using like this,

<div class="shell"><pre>
$ using sample.foo;
$ foo();
</pre></div>

<p>Then sample.foo is in namespace.


<h2>
	<a name="virtual_member">virtual member</a>
</h2>


<p>Orca objects have it's default virtual members.
If this members are not defined explicit, It works pre-defined way.

<p>belows are virtual members and It's meaning.

<h3>
	<a name="virt_type">type</a>
</h3>

<p>type type is data which explain object type. You can use this for type traits.
If you refer this as member of variable, It returns object type.

<p>first, you can check data type of object like this.

<div class="code"><pre>
a = 1;
a.type == 2.type; 
</pre></div>

above code check 1 and 2 has same type. 1 and 2 are same integer so it returns true.

<div class="code"><pre>
a.type == 2;
or
a.type == type.int;
</pre></div>

has same results.

<div class="code"><pre>
a.type != 2.type
</pre></div>

and above codes return false.


< operator of type means inheritance.

<div class="code"><pre>
a.type < b 
(or a.type < b.type)
</pre></div>

above code return true if a inherits b. if not, it returns false.


<= operator of type means instance.

<div class="code"><pre>
a.type <= b
(or a.type <= b.type)
</pre></div>

if a is instance of b, It returns true.




<h3>
	<a name="virt_typename">typename</a>
</h3>

typename return type of data as string


<div class="shell"><pre>
$ print: 1.typename;
int

$ print: r'regex'.typename;
regex

$ print: io.typename;
object io

$ print: [1,2,3].typename;
list
</pre></div>


<h3>
	<a name="virt_static">static_members</a>
</h3>

this member returns static members of object as map interface object.
map interface object means that It's not map but It supports some map interfaces.

<div class="code"><pre>
   def foo
   {
     static bar;
     def non_static;
   }

   a = my.foo.static_members;
   print: a;
   a['new_member'] = 1;
   print: a;
   print: my.foo.static_members;
   print: my.foo.new_member;
</pre></div>

<p>if you run above codes.


<div class="code"><pre>
{ 'bar':nil }
{ 'bar':nil,'new_member':1 }
{ 'bar':nil,'new_member':1 }
1
</pre></div>

<p>are printed. This static_member is worked like map but if you change It(static_member object)'s contents original static members in object foo is changed.

<p>static_members provides has_key, erase_key, keys, values, begin, last, end, find interfaces.
begin, last, end and find return iterator of static members.


<h3>
	<a name="virt_members">members</a>
</h3>


<p>static_members  return only static members of object. but, members member returns all static, non-static members
other aspects are same as static_members.


<h3>
	<a name="virt_parents">parents</a>
</h3>

<p>parents virtual member return parents list of object as list interface object.
It provides  push_back, pop_back, push_front, pop_front, begin, end, last, find interface.


<h3>
	<a name="virt_id">id</a>
</h3>

<p>id return unique number of object If it's remain in heap memory.


<div class="shell"><pre>
$   print: 1.id;
0

$    print: 'str'.id;
167178248

$    print: io.id;
166676848
</pre></div>







<h2>
	<a name="exception">exception</a>
</h2>


<p>orca can throw exception and it's syntax is simillar to other languages.
But throwed parameter is not object but path name.

<p>thorw io.error.disconnected
Like above communication module thows io.error.disconnected.<br>
But io.error.disconnected is not real object but just string path name.
If you want to catch excetption.<br>
You can write explicit catch like "catch io.error.disconnect" or implicit catch like "catch io.error" or "catch io"
So below code is possible


<div class="code"><pre>
try {
    …
    throw io.diconn;
    …
    throw io.timeout;
    …
    throw app.input.invalid;
    …
}
catch io.timeout {
    print: ‘timeout’;
}
catch io.disconn {
    print: ‘disconnected’;
}
catch io {
    print: ‘general io exception’;
}
catch app {
    print: ‘application exception’;
}
catch {
    print: ‘unknown exception’;
}
finally {
    print: ‘finally is always called ’;
}
</pre></div>

<p>orca choose path name (not object), so programmer make new exception type easily.
But you must be careful to mistyping.<br>
Type throw iio.error.disconnected make unwanted result.

<p>Hmm.. but someday, only registered pathes are possible for prevent mistyping.<br>
Other parameters are dilivered as object to catch code
Like this,


<div class="code"><pre>
try {
    throw app.test, 10, ‘test’;
}
catch app : num, msg {
    print: num, msg;
}
</pre></div>


<h2>
	<a name="lambda">lambda</a>
</h2>


<p>orca supports lambda function,
The grammar of lambda function is like this

<p>%c { statment_list }

<p>This code block has no name but it's same as normal orca object entirely.
It could have member objects and it's owner is who define it.
Belows are code in test_lambda.orca


<div class="code"><pre>
def for_each(list, functor) {
    for a in list: {
        functor(a);
    }
}

my.for_each([1..10], %c{ print(argv[0]); });

# below is same with above statement

my.for_each: [1..10], %c {
    print: argv[0];
};
</pre></div>

<p>As said before, lambda is object so 

<div class="shell"><pre>
$ a = %c { print: ‘foo’; };
$ a();
foo
</pre></div>

<p>It's possible assign, clone and any other operation for object.



<h2>
	<a name="operator">operator overloading</a>
</h2>


Operator overloading is described with famous example for complex operation.
Below code is in test_operator.orca


<div class="code"><pre>
def complex
   {
     def real;
     def img;
   
     def init(r, i) {
       ..real = r;
       ..img = i;
     }
   
     def '+'(rhs) {
       if owner.type == rhs:
           result = owner.clone(owner.real + rhs.real, owner.img + rhs.img);
       else:
           result = owner.clone(owner.real + rhs, owner.img);
       return result;
     }
   
     def '-'(rhs) {
       if owner.type == rhs:
           result = owner.clone(owner.real - rhs.real, owner.img - rhs.img);
       else:
           result = owner.clone(owner.real - rhs, owner.img);
       return result;
     }
   
     def '-rev'(lhs) {
       result = owner.clone(lhs - owner.real, -owner.img);
       return result;
     }
   
     def mag() {
       m = ..real * ..real + ..img * ..img;
       return m;
     }
   
     def '<'(rhs) {
       return ..mag() < rhs.mag();
     }
   
     def '=='(rhs) {
       return ..mag() == rhs.mag();
     }
   
　　def string() {
       return '${..real} + ${..img}j';
     }   
　} 
</pre></div>

<p>'+', '-', '*', '/', '<', '==' is overloading funciton and parameter is 
It's arguments that be placed in right side of operator.

<p>If you define '==' and '<', orca do '<=', '>', '>=' and '!=' automatically by using combination of '==' and '<'.
and orca provides '.attr', '.attr_last', '.attr=' as new overloading operators/
first, .attr('b') is called if a.b is referred but a has no member named 'b'.

<div class="code"><pre>
def day_of_month
{
	def ‘.attr’(name)
	{
		decode(name)
		{
		'January' -> return 31;
		'Febuary' -> return 28;
		'March' -> return 31;
		'April' -> return 30;
		'May' -> return 31;
		'June' -> return 30;
		'July' -> return 31;
		'August' -> return 31;
		'September' -> return 30;
		'October' -> return 31;
		'November' -> return 30;
		'December' -> return 31;
		}		

		throw orca.name, name + ' not found';
	}
}

$ p = my.day_of_month.clone();
$ print: p.April
30
$ print: p.foo
uncaugted exception: orca.name foo not found
recent call-stack trace
>> operator_get (internal 0)
>> orcaRoot     (internal 0)
</pre></div>

<p>like above, expression p.Apill finally called .attr('April')

<p>.attr=('b', 3) is called if a.b = 3 reffered but a has no member named 'b'

<p>.attr_last is something different. If this function is not defined only .attr is called.
but If this function is defined,

<p>If expresion a.b.c is reffered, a.'.attr'('b') is called because b is not last path of path expression(a.b.c, c is last)
and If expression a.b is reffred, a.'.attr_last'('b') is called because b is last path of path expression(a.b)
This is used for remote access, You can see useful usage of this in remotec.orca and remoted.orca.
<p>And you can overiding indexing operators.
‘[]’ and ‘[]=’ are those.

<p>If obj has [] and []= overiding operator,

<p>a = obj[b] calls a = obj.’[]’(b) and
obj[b] = c calles obj.’[]’(b, c)

<p>These operators make object like map or list interface.


<p>overloaded operator acts when object is at left hands side. but, If object is at right hands side and LHS object has no overided operator,
RHS object's operator is called.

<p>With an example,
If obj has overided + operator, 
obj + 1 calls obj.'+'(1) and 1 + obj calles obj.'+'(1)

<p>And if obj_b has + operator, obj + obj_b calls obj.'+'(obj_b) but obj_b + obj calls obj_b.'+'(obj).
Operator of LHS works first.

<p>And there is one more things to consider about this.
+ and * satisfy commutative law but - and / don't.

<p>So, obj - 1 calls obj.'-'(1) is ok and 1 - obj should not call obj.'-'(1).
In this case, 1 - obj calls obj.'-rev'(1) and 1 / obj calls obj.'/rev'(1).



<h1>
	<a name="special">Special object</a>
</h1>


<h2>
	<a name="native">Native object</a>
</h2>


orca is made by C++/boost so It's very easy to make native extension module.
In the orca project files, find and see orcaFile.h which is describe file module.




<div class="code"><pre>
class orcaFile : public orcaObject 
{
public:
    orcaFile(void* vp) : m_fp(NULL) { }

    orcaFile() : m_fp(NULL)
    {
        set_name("file");

        insert_native_function("open", (object_fp)&orcaFile::ex_open);
        insert_native_function("close", (object_fp)&orcaFile::ex_close);
        insert_native_function("read", (object_fp)&orcaFile::ex_read);
        insert_native_function("write", (object_fp)&orcaFile::ex_write);
    }

    ~orcaFile() {
        if (m_fp) {
            fclose(m_fp);
        }
    }

    orcaObject* v_clone() {
        orcaFile* fp = new orcaFile(NULL);
        return fp;
    }

    orcaData ex_open(orcaVM* vm, int n) 
    {
        if (n<1) {
            return NIL;
        }

        string& name = vm->get_param(0).String();

        string mode;
        if (is<TYPE_NIL>(vm->get_param(1))) 
            mode = "rw";
        else
            mode = vm->get_param(1).String();

        if (m_fp != NULL) {
            fclose(m_fp);
        }

        m_fp = fopen(name.c_str(), mode.c_str());
        if (m_fp == NULL) {
            throw orcaException("io.file.handle", "invalide file handle");
        }

        fseek(m_fp, 0, SEEK_END);
        m_size = ftell(m_fp);
        fseek(m_fp, 0, SEEK_SET);

        return NIL;
    }

    orcaData ex_close(orcaVM* vm, int n) 
    {
        if (m_fp != NULL) {
            fclose(m_fp);
            m_fp = NULL;
        }

        return NIL;
    }

    orcaData ex_read(orcaVM* vm, int n) 
    {
        if (m_fp == NULL) {
            return NIL;
        }

        string s;
        s.resize(m_size);

        fread(&s[0], 1, m_size, m_fp);
        s.resize(strlen(&s[0]));

        return s;
    }

    orcaData ex_write(orcaVM* vm, int n) 
    {
        string& in = vm->get_param(0).String();

        if (m_fp == NULL) {
            return NIL;
        }

        return (int)fwrite(in.c_str(), 1, in.length()+1, m_fp);
    }

private:
    FILE* m_fp;
    int m_size;
};
</pre></div>


Almost all interpreter languages supports to make native extension call.
But like above, It's simple and easy because there is C++ orcaFile class which represents file module in orca.

<p>This is internal source code. so if you want build up dynamic library add additional code to use it runtime.
If you make extension module and name it as sample.dll or libsample.so, add get_sample in it with prototype 
extern "C" void* get_sample(). 

<p>And in this function, make your object and return it as type of orcaObject* 



<div class="code"><pre>
#include "stdafx.h"
#include "sample.h"

extern "C" SAMPLE_API void samplefoo()
{
    printf("foo called\n");
}

class sample : public orcaObject
{
public: 
    orcaData operator()(orcaVM* vm, int param_n) {
        printf("sample called\n");

        int a, b;
        a=vm->get_param(0).Integer();
        b=vm->get_param(1).Integer();

        return a + b;
    }
};

extern "C" SAMPLE_API void* get_sample() 
{
    sample* sp = new sample();
    return sp;
}
</pre></div>

<p>This code is sample dll source which is included in orca project.
get_sample returns new orcaObject* sample.

<p>object sample's excution is built by operator(). It gets two integer parameters
and sum up and return (by pushing it to stack frame)

<p>If you add another object into this module try like orcaFile.h in case of native code.
or try like orcaIO.h if you add real orcaObject into it.
Here is that part of orcaIO.h


<div class="code"><pre>
class orcaIO : public orcaObject 
{
public:

    class ex_print : public orcaObject 
    {
    public:
        virtual orcaData operator()(orcaVM* vm, int n) {
            string str;
            for (int i=0; i<n; i++) 
                vm->get_param(i).to_str(vm, str);

            str += "\n";

            cout << str;

            return NIL;
        }
    };

    orcaIO() 
    {
        set_name("io");
        insert_static("print", new ex_print());
    }
};
</pre></div>


<h2>
	<a name="parse">parse object</a>
</h2>

<p>Orca has LALR(1) parser generator in it. so if you use it, you can make your own syntax parser very easily.

<p>basic operation is same as BNF notation of bison (or yacc).
but, It contains it's lexical analyser in it.

<p>below example is simple calculator examlple


<div class="code"><pre>
parse def calc(str)
   {
       stmt : stmt '+' mul
                   %c{
                       return argv[0] + argv[2];
                   }
           | stmt '-' mul
                   %c{
                       return argv[0] - argv[2];
                   }
           | mul
                   %c{
                       return argv[0];
                   }
           ;
   
       mul : mul '*' number
                   %c{
                       return argv[0] * argv[2];
                   }
           |  mul '/' number 
                   %c{
                       return argv[0] / argv[2];
                   }
           | number
                   %c{
                       return argv[0];
                   }  
           ; 
   
       number : r'[0-9]+' 
                   %c{
                       return argv[0].integer(); 
                   } 
           ;
   
       ~ : r'[ \t\r\n]+'
	;
}
</pre></div>

<p>if you run my.calc('3+4*2'), It returns 11

<p>This part requires knowledge about BNF & parsing process to understand all.
so, I'll describe other articles about that. In this tutorial let's see different facts with bison.

<p>strings and regular expressions in object are terminals. Orca get token from input stream by using above terminals.
in grammar ~ : r'[ \t\r\n]+', left ~ means don't use right terminal. (ignore right side terminal) 
if grammar is matched, lambda object of right side is called. Input parameters are argv list which is composed by return values of matched nodes.

<p>This is simple example, So if you want another complex one, See the lib/lisp.orca. lisp.orca is common lisp module which is made by parse statement.




<h2>
	<a name="uds">User Define Statement(UDS) object</a>
</h2>


<p>UDS object handle statements that user defines in orca source file.
handle means It get it's text code and compile and make result object itself.

<p>by UDS, Orca can contain DSL in it's source code.

<p>for a simple example, let's see below,


<div class="code"><pre>
a = %cpp{
  // this is cpp code
  cout << "hello, " << argv[0].String() << endl;
};

a('world');
</pre></div>

<p>this code prints 'hello, world'. and internal codes in %cpp{ ... } is written by C++ language.
If %name{ statement } is appear, Orca call name module and pass statement code, timestamp of source code and unique name.
That means orca call cpp(statement, unique_name, source_datetime)

<p>cpp module check unique_name and source_datetime. If there is no dynamic extension library or source_datetime is newer than dynamic library, cpp module recompile statement and save it as unique_name.so
And finally, open that dynamic library and get result object.

<p>This is simillar to inline assembly in C language. but It's different because This UDS can be used for other languages or context which user want to handle.
And another difference is result of UDS is independent object, so It doesn't harm readability.

<p>Default supported UDS module libraries in orca are cpp, lisp and sh.
You can see these in lib folder and understand how it works.







<h2>
	<a name="onetime">one time evaluation expression</a>
</h2>


<p>One time evaluated expression is evaluated at first time and then save its result to file.
Then this saved result is used after.

<p>%1{ } is mark for one time evaluated expression.
See the below example.


<div class="code"><pre>
using stopwatch;
using fibonacci;

stopwatch.title('elapsed: ') {
  a = %1{ fibonacci(20); };
}
print: a;
</pre></div>

<p>If you run this codes first time, fibonacci(20) is evaluated. So execution time is long (512ms in this case)
And then, If you run this codes twice or more, saved result is used for %1{ } expression. so It takes just 99us.

<div class="shell"><pre>
$ ../orca test.orca
elapsed: 276 ms, 17 us
6765
$ ../orca test.orca
elapsed: 11 us
6765
</pre></div>

<p>Evaluated result is saved as test.orca.once file and It loaded to VM when test.orca module is loaded



<h2>
	<a name="pure">pure object</a>
</h2>


<p>If result of function is only depend on its parameter. We called it as pure function.
For an example,

<div class="code"><pre>
def sum(a, b)
{
  return a + b;
}
</pre></div>

<p>This function’s result is only depend on a, b. so sum is pure function.

<p>As another famous pure function is Fibonacci function.
<p>Its defined like,



<div class="code"><pre>
   def fibonacci(n)
   {
       if n == 0:
           return 0;

       if n == 1:
           return 1;

       return fibonacci(n-1) + fibonacci(n-2);
   }
</pre></div>

<p>The result of fibonacci function depends on input N. and It has recursive call in it so if N is bigger, execution time is increase extremely.

<p>So below, Fibonacci example takes about 1.5 sec.

<div class="code"><pre>
using stopwatch;
using fibonacci;

stopwatch.title('elapsed: ') {
  a = fibonacci(22);
}

print: a;

elapsed: 1 sec, 597 ms, 555 us                                                                                                     
46368
</pre></div>

<p>fibonacci(22) is sum of fibonacci(21) and fibonacci(20). Fibonacci(21) is sum of fibonacci(20) and fibonacci(19). In this codes, every fibonacci(N) is calculated each time. 
But If we can reuse result of fibonacci(N). execution time is extremely fast.

<p>If you add 'pure' on object when it is defined. Orca VM cacheing the results of that object and reuse if possible.
So, If you rewritre fibonacci codes like below (just add pure)


<div class="code"><pre>
   pure def fibonacci(n)
   {
       if n == 0:
           return 0;
   
       if n == 1:
           return 1;
   
       return fibonacci(n-1) + fibonacci(n-2);
   }
</pre></div>

and rerun above example, It's execution time is extremeley shorten.

<div class="code"><pre>
elapsed: 370 us
46368
</pre></div>

caching results of pure function is managed by LRU list. and oldest one is removede automatically.











</body>
</html>



